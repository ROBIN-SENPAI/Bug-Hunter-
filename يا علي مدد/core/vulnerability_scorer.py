"""
vulnerability_scorer.py
تقييم خطورة الثغرات (CVSS Scoring)
"""

from typing import Dict, Optional
from enum import Enum


class Severity(Enum):
    """مستويات الخطورة"""
    CRITICAL = "critical"
    HIGH = "high"
    MEDIUM = "medium"
    LOW = "low"
    INFO = "info"


class VulnerabilityScorer:
    """تقييم خطورة الثغرات"""
    
    def __init__(self):
        # تقييمات افتراضية للثغرات
        self.default_scores = {
            'sql_injection': 9.8,
            'command_injection': 10.0,
            'remote_code_execution': 10.0,
            'xss_stored': 7.5,
            'xss_reflected': 6.5,
            'xss_dom': 6.0,
            'xxe': 8.5,
            'ssrf': 8.0,
            'lfi': 7.5,
            'rfi': 9.0,
            'path_traversal': 7.0,
            'authentication_bypass': 9.0,
            'privilege_escalation': 8.5,
            'idor': 7.0,
            'csrf': 6.5,
            'open_redirect': 5.5,
            'clickjacking': 4.5,
            'information_disclosure': 5.0,
            'weak_credentials': 7.0,
            'jwt_vulnerability': 7.5,
            'deserialization': 9.0,
            'cors_misconfiguration': 6.0,
            'security_headers_missing': 3.0,
            'subdomain_takeover': 7.5,
            'host_header_injection': 6.5,
            'cache_poisoning': 7.0
        }
    
    def calculate_score(self, 
                       vuln_type: str,
                       context: Optional[Dict] = None) -> float:
        """
        حساب درجة الخطورة
        
        Args:
            vuln_type: نوع الثغرة
            context: سياق إضافي (authentication_required, data_exposure, etc)
        """
        base_score = self.default_scores.get(vuln_type.lower(), 5.0)
        
        if not context:
            return base_score
        
        # تعديل الدرجة بناءً على السياق
        modifiers = 0.0
        
        # هل تتطلب مصادقة؟
        if context.get('authentication_required', False):
            modifiers -= 1.5
        
        # هل تكشف بيانات حساسة؟
        if context.get('data_exposure', False):
            modifiers += 1.0
        
        # هل يمكن استغلالها عن بعد؟
        if context.get('remote_exploitation', True):
            modifiers += 0.5
        
        # هل الاستغلال سهل؟
        exploitation_difficulty = context.get('exploitation_difficulty', 'medium')
        if exploitation_difficulty == 'easy':
            modifiers += 1.0
        elif exploitation_difficulty == 'hard':
            modifiers -= 1.0
        
        # هل موجودة في بيئة الإنتاج؟
        if context.get('production_environment', True):
            modifiers += 0.5
        else:
            modifiers -= 2.0  # بيئة تطوير أو تجريبية
        
        # الحد الأقصى والأدنى
        final_score = max(0.0, min(10.0, base_score + modifiers))
        
        return round(final_score, 1)
    
    def get_severity(self, score: float) -> Severity:
        """تحديد مستوى الخطورة من الدرجة"""
        if score >= 9.0:
            return Severity.CRITICAL
        elif score >= 7.0:
            return Severity.HIGH
        elif score >= 4.0:
            return Severity.MEDIUM
        elif score >= 0.1:
            return Severity.LOW
        else:
            return Severity.INFO
    
    def get_severity_color(self, severity: Severity) -> str:
        """الحصول على لون الخطورة"""
        colors = {
            Severity.CRITICAL: '🔴',
            Severity.HIGH: '🟠',
            Severity.MEDIUM: '🟡',
            Severity.LOW: '🟢',
            Severity.INFO: 'ℹ️'
        }
        return colors.get(severity, 'ℹ️')
    
    def calculate_cvss_vector(self, 
                            attack_vector: str = 'N',
                            attack_complexity: str = 'L',
                            privileges_required: str = 'N',
                            user_interaction: str = 'N',
                            scope: str = 'U',
                            confidentiality: str = 'H',
                            integrity: str = 'H',
                            availability: str = 'H') -> Dict:
        """
        حساب CVSS v3.1 Score
        
        Attack Vector (AV): N=Network, A=Adjacent, L=Local, P=Physical
        Attack Complexity (AC): L=Low, H=High
        Privileges Required (PR): N=None, L=Low, H=High
        User Interaction (UI): N=None, R=Required
        Scope (S): U=Unchanged, C=Changed
        Confidentiality (C): N=None, L=Low, H=High
        Integrity (I): N=None, L=Low, H=High
        Availability (A): N=None, L=Low, H=High
        """
        
        # تبسيط حساب CVSS (يمكن تحسينه باستخدام المعادلة الكاملة)
        scores = {
            'AV': {'N': 0.85, 'A': 0.62, 'L': 0.55, 'P': 0.2},
            'AC': {'L': 0.77, 'H': 0.44},
            'PR': {'N': 0.85, 'L': 0.62, 'H': 0.27},
            'UI': {'N': 0.85, 'R': 0.62},
            'C': {'H': 0.56, 'L': 0.22, 'N': 0},
            'I': {'H': 0.56, 'L': 0.22, 'N': 0},
            'A': {'H': 0.56, 'L': 0.22, 'N': 0}
        }
        
        # حساب مبسط
        impact = (scores['C'][confidentiality] + 
                 scores['I'][integrity] + 
                 scores['A'][availability])
        
        exploitability = (scores['AV'][attack_vector] * 
                         scores['AC'][attack_complexity] * 
                         scores['PR'][privileges_required] * 
                         scores['UI'][user_interaction])
        
        base_score = min(10.0, (impact * exploitability * 1.08))
        
        vector_string = f"CVSS:3.1/AV:{attack_vector}/AC:{attack_complexity}/PR:{privileges_required}/UI:{user_interaction}/S:{scope}/C:{confidentiality}/I:{integrity}/A:{availability}"
        
        return {
            'score': round(base_score, 1),
            'vector': vector_string,
            'severity': self.get_severity(base_score).value
        }
    
    def assess_vulnerability(self, vulnerability: Dict) -> Dict:
        """تقييم ثغرة كاملة"""
        vuln_type = vulnerability.get('type', 'unknown')
        context = vulnerability.get('context', {})
        
        score = self.calculate_score(vuln_type, context)
        severity = self.get_severity(score)
        
        return {
            'type': vuln_type,
            'score': score,
            'severity': severity.value,
            'severity_icon': self.get_severity_color(severity),
            'url': vulnerability.get('url', ''),
            'parameter': vulnerability.get('parameter', ''),
            'description': vulnerability.get('description', ''),
            'remediation': self.get_remediation(vuln_type)
        }
    
    def get_remediation(self, vuln_type: str) -> str:
        """الحصول على توصيات الإصلاح"""
        remediations = {
            'sql_injection': 'Use parameterized queries or prepared statements',
            'xss_reflected': 'Implement proper input validation and output encoding',
            'xss_stored': 'Sanitize user input and use Content Security Policy',
            'command_injection': 'Avoid using system calls with user input',
            'lfi': 'Validate and sanitize file paths, use whitelist approach',
            'xxe': 'Disable external entity processing in XML parsers',
            'ssrf': 'Implement strict URL validation and use allowlist',
            'csrf': 'Implement anti-CSRF tokens',
            'authentication_bypass': 'Review authentication logic and implement MFA',
            'idor': 'Implement proper authorization checks',
            'open_redirect': 'Validate redirect URLs against whitelist',
            'jwt_vulnerability': 'Use strong signing algorithms and validate tokens properly'
        }
        
        return remediations.get(vuln_type.lower(), 'Review security best practices')
    
    def prioritize_vulnerabilities(self, vulnerabilities: list) -> list:
        """ترتيب الثغرات حسب الأولوية"""
        assessed = [self.assess_vulnerability(v) for v in vulnerabilities]
        
        # ترتيب حسب الدرجة (من الأعلى للأقل)
        sorted_vulns = sorted(assessed, key=lambda x: x['score'], reverse=True)
        
        return sorted_vulns
    
    def generate_risk_score(self, vulnerabilities: list) -> Dict:
        """حساب درجة المخاطر الإجمالية"""
        if not vulnerabilities:
            return {
                'overall_risk': 0.0,
                'risk_level': 'Low',
                'total_vulnerabilities': 0
            }
        
        scores = [self.calculate_score(v.get('type', ''), v.get('context', {})) 
                 for v in vulnerabilities]
        
        # المتوسط المرجح
        critical_count = sum(1 for s in scores if s >= 9.0)
        high_count = sum(1 for s in scores if 7.0 <= s < 9.0)
        
        overall_risk = (sum(scores) / len(scores)) * (1 + (critical_count * 0.2) + (high_count * 0.1))
        overall_risk = min(10.0, overall_risk)
        
        if overall_risk >= 8.0:
            risk_level = 'Critical'
        elif overall_risk >= 6.0:
            risk_level = 'High'
        elif overall_risk >= 4.0:
            risk_level = 'Medium'
        else:
            risk_level = 'Low'
        
        return {
            'overall_risk': round(overall_risk, 1),
            'risk_level': risk_level,
            'total_vulnerabilities': len(vulnerabilities),
            'critical_count': critical_count,
            'high_count': high_count
        }