"""
vulnerability_scorer.py
ØªÙ‚ÙŠÙŠÙ… Ø®Ø·ÙˆØ±Ø© Ø§Ù„Ø«ØºØ±Ø§Øª (CVSS Scoring)
"""

from typing import Dict, Optional
from enum import Enum


class Severity(Enum):
    """Ù…Ø³ØªÙˆÙŠØ§Øª Ø§Ù„Ø®Ø·ÙˆØ±Ø©"""
    CRITICAL = "critical"
    HIGH = "high"
    MEDIUM = "medium"
    LOW = "low"
    INFO = "info"


class VulnerabilityScorer:
    """ØªÙ‚ÙŠÙŠÙ… Ø®Ø·ÙˆØ±Ø© Ø§Ù„Ø«ØºØ±Ø§Øª"""
    
    def __init__(self):
        # ØªÙ‚ÙŠÙŠÙ…Ø§Øª Ø§ÙØªØ±Ø§Ø¶ÙŠØ© Ù„Ù„Ø«ØºØ±Ø§Øª
        self.default_scores = {
            'sql_injection': 9.8,
            'command_injection': 10.0,
            'remote_code_execution': 10.0,
            'xss_stored': 7.5,
            'xss_reflected': 6.5,
            'xss_dom': 6.0,
            'xxe': 8.5,
            'ssrf': 8.0,
            'lfi': 7.5,
            'rfi': 9.0,
            'path_traversal': 7.0,
            'authentication_bypass': 9.0,
            'privilege_escalation': 8.5,
            'idor': 7.0,
            'csrf': 6.5,
            'open_redirect': 5.5,
            'clickjacking': 4.5,
            'information_disclosure': 5.0,
            'weak_credentials': 7.0,
            'jwt_vulnerability': 7.5,
            'deserialization': 9.0,
            'cors_misconfiguration': 6.0,
            'security_headers_missing': 3.0,
            'subdomain_takeover': 7.5,
            'host_header_injection': 6.5,
            'cache_poisoning': 7.0
        }
    
    def calculate_score(self, 
                       vuln_type: str,
                       context: Optional[Dict] = None) -> float:
        """
        Ø­Ø³Ø§Ø¨ Ø¯Ø±Ø¬Ø© Ø§Ù„Ø®Ø·ÙˆØ±Ø©
        
        Args:
            vuln_type: Ù†ÙˆØ¹ Ø§Ù„Ø«ØºØ±Ø©
            context: Ø³ÙŠØ§Ù‚ Ø¥Ø¶Ø§ÙÙŠ (authentication_required, data_exposure, etc)
        """
        base_score = self.default_scores.get(vuln_type.lower(), 5.0)
        
        if not context:
            return base_score
        
        # ØªØ¹Ø¯ÙŠÙ„ Ø§Ù„Ø¯Ø±Ø¬Ø© Ø¨Ù†Ø§Ø¡Ù‹ Ø¹Ù„Ù‰ Ø§Ù„Ø³ÙŠØ§Ù‚
        modifiers = 0.0
        
        # Ù‡Ù„ ØªØªØ·Ù„Ø¨ Ù…ØµØ§Ø¯Ù‚Ø©ØŸ
        if context.get('authentication_required', False):
            modifiers -= 1.5
        
        # Ù‡Ù„ ØªÙƒØ´Ù Ø¨ÙŠØ§Ù†Ø§Øª Ø­Ø³Ø§Ø³Ø©ØŸ
        if context.get('data_exposure', False):
            modifiers += 1.0
        
        # Ù‡Ù„ ÙŠÙ…ÙƒÙ† Ø§Ø³ØªØºÙ„Ø§Ù„Ù‡Ø§ Ø¹Ù† Ø¨Ø¹Ø¯ØŸ
        if context.get('remote_exploitation', True):
            modifiers += 0.5
        
        # Ù‡Ù„ Ø§Ù„Ø§Ø³ØªØºÙ„Ø§Ù„ Ø³Ù‡Ù„ØŸ
        exploitation_difficulty = context.get('exploitation_difficulty', 'medium')
        if exploitation_difficulty == 'easy':
            modifiers += 1.0
        elif exploitation_difficulty == 'hard':
            modifiers -= 1.0
        
        # Ù‡Ù„ Ù…ÙˆØ¬ÙˆØ¯Ø© ÙÙŠ Ø¨ÙŠØ¦Ø© Ø§Ù„Ø¥Ù†ØªØ§Ø¬ØŸ
        if context.get('production_environment', True):
            modifiers += 0.5
        else:
            modifiers -= 2.0  # Ø¨ÙŠØ¦Ø© ØªØ·ÙˆÙŠØ± Ø£Ùˆ ØªØ¬Ø±ÙŠØ¨ÙŠØ©
        
        # Ø§Ù„Ø­Ø¯ Ø§Ù„Ø£Ù‚ØµÙ‰ ÙˆØ§Ù„Ø£Ø¯Ù†Ù‰
        final_score = max(0.0, min(10.0, base_score + modifiers))
        
        return round(final_score, 1)
    
    def get_severity(self, score: float) -> Severity:
        """ØªØ­Ø¯ÙŠØ¯ Ù…Ø³ØªÙˆÙ‰ Ø§Ù„Ø®Ø·ÙˆØ±Ø© Ù…Ù† Ø§Ù„Ø¯Ø±Ø¬Ø©"""
        if score >= 9.0:
            return Severity.CRITICAL
        elif score >= 7.0:
            return Severity.HIGH
        elif score >= 4.0:
            return Severity.MEDIUM
        elif score >= 0.1:
            return Severity.LOW
        else:
            return Severity.INFO
    
    def get_severity_color(self, severity: Severity) -> str:
        """Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ù„ÙˆÙ† Ø§Ù„Ø®Ø·ÙˆØ±Ø©"""
        colors = {
            Severity.CRITICAL: 'ðŸ”´',
            Severity.HIGH: 'ðŸŸ ',
            Severity.MEDIUM: 'ðŸŸ¡',
            Severity.LOW: 'ðŸŸ¢',
            Severity.INFO: 'â„¹ï¸'
        }
        return colors.get(severity, 'â„¹ï¸')
    
    def calculate_cvss_vector(self, 
                            attack_vector: str = 'N',
                            attack_complexity: str = 'L',
                            privileges_required: str = 'N',
                            user_interaction: str = 'N',
                            scope: str = 'U',
                            confidentiality: str = 'H',
                            integrity: str = 'H',
                            availability: str = 'H') -> Dict:
        """
        Ø­Ø³Ø§Ø¨ CVSS v3.1 Score
        
        Attack Vector (AV): N=Network, A=Adjacent, L=Local, P=Physical
        Attack Complexity (AC): L=Low, H=High
        Privileges Required (PR): N=None, L=Low, H=High
        User Interaction (UI): N=None, R=Required
        Scope (S): U=Unchanged, C=Changed
        Confidentiality (C): N=None, L=Low, H=High
        Integrity (I): N=None, L=Low, H=High
        Availability (A): N=None, L=Low, H=High
        """
        
        # ØªØ¨Ø³ÙŠØ· Ø­Ø³Ø§Ø¨ CVSS (ÙŠÙ…ÙƒÙ† ØªØ­Ø³ÙŠÙ†Ù‡ Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„Ù…Ø¹Ø§Ø¯Ù„Ø© Ø§Ù„ÙƒØ§Ù…Ù„Ø©)
        scores = {
            'AV': {'N': 0.85, 'A': 0.62, 'L': 0.55, 'P': 0.2},
            'AC': {'L': 0.77, 'H': 0.44},
            'PR': {'N': 0.85, 'L': 0.62, 'H': 0.27},
            'UI': {'N': 0.85, 'R': 0.62},
            'C': {'H': 0.56, 'L': 0.22, 'N': 0},
            'I': {'H': 0.56, 'L': 0.22, 'N': 0},
            'A': {'H': 0.56, 'L': 0.22, 'N': 0}
        }
        
        # Ø­Ø³Ø§Ø¨ Ù…Ø¨Ø³Ø·
        impact = (scores['C'][confidentiality] + 
                 scores['I'][integrity] + 
                 scores['A'][availability])
        
        exploitability = (scores['AV'][attack_vector] * 
                         scores['AC'][attack_complexity] * 
                         scores['PR'][privileges_required] * 
                         scores['UI'][user_interaction])
        
        base_score = min(10.0, (impact * exploitability * 1.08))
        
        vector_string = f"CVSS:3.1/AV:{attack_vector}/AC:{attack_complexity}/PR:{privileges_required}/UI:{user_interaction}/S:{scope}/C:{confidentiality}/I:{integrity}/A:{availability}"
        
        return {
            'score': round(base_score, 1),
            'vector': vector_string,
            'severity': self.get_severity(base_score).value
        }
    
    def assess_vulnerability(self, vulnerability: Dict) -> Dict:
        """ØªÙ‚ÙŠÙŠÙ… Ø«ØºØ±Ø© ÙƒØ§Ù…Ù„Ø©"""
        vuln_type = vulnerability.get('type', 'unknown')
        context = vulnerability.get('context', {})
        
        score = self.calculate_score(vuln_type, context)
        severity = self.get_severity(score)
        
        return {
            'type': vuln_type,
            'score': score,
            'severity': severity.value,
            'severity_icon': self.get_severity_color(severity),
            'url': vulnerability.get('url', ''),
            'parameter': vulnerability.get('parameter', ''),
            'description': vulnerability.get('description', ''),
            'remediation': self.get_remediation(vuln_type)
        }
    
    def get_remediation(self, vuln_type: str) -> str:
        """Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ ØªÙˆØµÙŠØ§Øª Ø§Ù„Ø¥ØµÙ„Ø§Ø­"""
        remediations = {
            'sql_injection': 'Use parameterized queries or prepared statements',
            'xss_reflected': 'Implement proper input validation and output encoding',
            'xss_stored': 'Sanitize user input and use Content Security Policy',
            'command_injection': 'Avoid using system calls with user input',
            'lfi': 'Validate and sanitize file paths, use whitelist approach',
            'xxe': 'Disable external entity processing in XML parsers',
            'ssrf': 'Implement strict URL validation and use allowlist',
            'csrf': 'Implement anti-CSRF tokens',
            'authentication_bypass': 'Review authentication logic and implement MFA',
            'idor': 'Implement proper authorization checks',
            'open_redirect': 'Validate redirect URLs against whitelist',
            'jwt_vulnerability': 'Use strong signing algorithms and validate tokens properly'
        }
        
        return remediations.get(vuln_type.lower(), 'Review security best practices')
    
    def prioritize_vulnerabilities(self, vulnerabilities: list) -> list:
        """ØªØ±ØªÙŠØ¨ Ø§Ù„Ø«ØºØ±Ø§Øª Ø­Ø³Ø¨ Ø§Ù„Ø£ÙˆÙ„ÙˆÙŠØ©"""
        assessed = [self.assess_vulnerability(v) for v in vulnerabilities]
        
        # ØªØ±ØªÙŠØ¨ Ø­Ø³Ø¨ Ø§Ù„Ø¯Ø±Ø¬Ø© (Ù…Ù† Ø§Ù„Ø£Ø¹Ù„Ù‰ Ù„Ù„Ø£Ù‚Ù„)
        sorted_vulns = sorted(assessed, key=lambda x: x['score'], reverse=True)
        
        return sorted_vulns
    
    def generate_risk_score(self, vulnerabilities: list) -> Dict:
        """Ø­Ø³Ø§Ø¨ Ø¯Ø±Ø¬Ø© Ø§Ù„Ù…Ø®Ø§Ø·Ø± Ø§Ù„Ø¥Ø¬Ù…Ø§Ù„ÙŠØ©"""
        if not vulnerabilities:
            return {
                'overall_risk': 0.0,
                'risk_level': 'Low',
                'total_vulnerabilities': 0
            }
        
        scores = [self.calculate_score(v.get('type', ''), v.get('context', {})) 
                 for v in vulnerabilities]
        
        # Ø§Ù„Ù…ØªÙˆØ³Ø· Ø§Ù„Ù…Ø±Ø¬Ø­
        critical_count = sum(1 for s in scores if s >= 9.0)
        high_count = sum(1 for s in scores if 7.0 <= s < 9.0)
        
        overall_risk = (sum(scores) / len(scores)) * (1 + (critical_count * 0.2) + (high_count * 0.1))
        overall_risk = min(10.0, overall_risk)
        
        if overall_risk >= 8.0:
            risk_level = 'Critical'
        elif overall_risk >= 6.0:
            risk_level = 'High'
        elif overall_risk >= 4.0:
            risk_level = 'Medium'
        else:
            risk_level = 'Low'
        
        return {
            'overall_risk': round(overall_risk, 1),
            'risk_level': risk_level,
            'total_vulnerabilities': len(vulnerabilities),
            'critical_count': critical_count,
            'high_count': high_count
        }